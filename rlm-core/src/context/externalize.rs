//! Context externalization to prevent context rot.
//!
//! This module implements the "context-as-variable" pattern from Codecrack3 RLM-DSPy.
//! The root LLM receives only the query and variable summaries, while full context
//! is stored as Python variables accessible via REPL helpers.
//!
//! # Benefits
//!
//! - Prevents performance degradation from lengthy context in prompts
//! - Enables lazy loading of context on demand
//! - Supports large context that wouldn't fit in prompt
//! - Provides structured access patterns (peek, search, summarize)
//!
//! # SPEC-25: Context Externalization
//!
//! - SPEC-25.01: Context variable types and externalization
//! - SPEC-25.02: Root prompt generation without full context
//! - SPEC-25.03: Variable access helpers for REPL
//! - SPEC-25.04: Size tracking and limits

use super::types::SessionContext;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Size thresholds for context variables (SPEC-25.04).
pub const WARN_SIZE_BYTES: usize = 100 * 1024; // 100 KB
pub const REQUIRE_CHUNKING_BYTES: usize = 1024 * 1024; // 1 MB

/// Configuration for context size policy decisions.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SizeConfig {
    /// Warning threshold per variable (bytes).
    pub warn_threshold: usize,
    /// Chunking threshold per variable (bytes).
    pub chunk_threshold: usize,
    /// Maximum total externalized context size (bytes).
    pub max_total_size: usize,
}

impl Default for SizeConfig {
    fn default() -> Self {
        Self {
            warn_threshold: WARN_SIZE_BYTES,
            chunk_threshold: REQUIRE_CHUNKING_BYTES,
            max_total_size: 10 * 1024 * 1024, // 10 MB
        }
    }
}

/// Size policy warning generated by `check_size_limits`.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum SizeWarning {
    /// Variable exceeds warning threshold.
    LargeVariable {
        name: String,
        size: usize,
        threshold: usize,
    },
    /// Variable exceeds chunking threshold.
    RequiresChunking {
        name: String,
        size: usize,
        suggested_chunks: usize,
    },
    /// Total size exceeds max configured limit.
    TotalSizeExceeded { total: usize, max: usize },
}

impl SizeWarning {
    /// Convert warning to a deterministic human-readable message.
    pub fn message(&self) -> String {
        match self {
            Self::LargeVariable {
                name,
                size,
                threshold,
            } => format!(
                "{} exceeds warning threshold ({} bytes > {} bytes)",
                name, size, threshold
            ),
            Self::RequiresChunking {
                name,
                size,
                suggested_chunks,
            } => format!(
                "{} requires chunking ({} bytes, suggested_chunks={})",
                name, size, suggested_chunks
            ),
            Self::TotalSizeExceeded { total, max } => format!(
                "total externalized context exceeds max ({} bytes > {} bytes)",
                total, max
            ),
        }
    }
}

/// Type of context variable.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ContextVarType {
    /// Conversation history (List[Message]).
    Conversation,
    /// Cached file contents (Dict[str, str]).
    Files,
    /// Tool execution outputs (List[ToolOutput]).
    ToolOutputs,
    /// Working memory (Dict[str, Any]).
    WorkingMemory,
    /// Custom variable type.
    Custom(String),
}

impl std::fmt::Display for ContextVarType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Conversation => write!(f, "conversation"),
            Self::Files => write!(f, "files"),
            Self::ToolOutputs => write!(f, "tool_outputs"),
            Self::WorkingMemory => write!(f, "working_memory"),
            Self::Custom(name) => write!(f, "{}", name),
        }
    }
}

/// A context variable stored in the REPL namespace.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContextVariable {
    /// Variable name in REPL namespace.
    pub name: String,
    /// Type of the variable.
    pub var_type: ContextVarType,
    /// Size in bytes (for tracking limits).
    pub size_bytes: usize,
    /// Brief summary for the LLM (NOT the full content).
    pub summary: String,
    /// Whether this variable exceeds the warning threshold.
    pub size_warning: bool,
    /// Whether this variable requires chunking.
    pub requires_chunking: bool,
    /// Number of chunks created (if auto-chunked).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub chunk_count: Option<usize>,
    /// Number of items (messages, files, etc.).
    pub item_count: usize,
}

impl ContextVariable {
    /// Create a new context variable.
    pub fn new(
        name: impl Into<String>,
        var_type: ContextVarType,
        size_bytes: usize,
        item_count: usize,
    ) -> Self {
        Self::new_with_config(name, var_type, size_bytes, item_count, &SizeConfig::default())
    }

    /// Create a new context variable with explicit size-policy config.
    pub fn new_with_config(
        name: impl Into<String>,
        var_type: ContextVarType,
        size_bytes: usize,
        item_count: usize,
        size_config: &SizeConfig,
    ) -> Self {
        let name = name.into();
        let summary = Self::generate_summary(&var_type, item_count, size_bytes);
        Self {
            name,
            var_type,
            size_bytes,
            summary,
            size_warning: size_bytes > size_config.warn_threshold,
            requires_chunking: size_bytes > size_config.chunk_threshold,
            chunk_count: None,
            item_count,
        }
    }

    fn generate_summary(var_type: &ContextVarType, count: usize, size: usize) -> String {
        let size_str = if size < 1024 {
            format!("{} bytes", size)
        } else if size < 1024 * 1024 {
            format!("{:.1} KB", size as f64 / 1024.0)
        } else {
            format!("{:.1} MB", size as f64 / (1024.0 * 1024.0))
        };

        match var_type {
            ContextVarType::Conversation => {
                format!("{} messages (~{})", count, size_str)
            }
            ContextVarType::Files => {
                format!("{} files (~{})", count, size_str)
            }
            ContextVarType::ToolOutputs => {
                format!("{} tool outputs (~{})", count, size_str)
            }
            ContextVarType::WorkingMemory => {
                format!("{} entries (~{})", count, size_str)
            }
            ContextVarType::Custom(name) => {
                format!("{}: {} items (~{})", name, count, size_str)
            }
        }
    }

    /// Apply an auto-chunk annotation to this variable.
    pub fn mark_chunked(&mut self, chunks: usize) {
        self.chunk_count = Some(chunks.max(1));
        self.requires_chunking = false;
        self.summary = Self::generate_summary(&self.var_type, self.item_count, self.size_bytes);
        self.summary
            .push_str(&format!(" [auto_chunked into {} chunks]", chunks.max(1)));
    }
}

/// Externalized context with query and variable summaries (SPEC-25.01).
///
/// The LLM receives only the query and variable summaries.
/// Full context is stored as REPL variables.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExternalizedContext {
    /// The user's query (sent to LLM).
    pub query: String,
    /// Variables available in REPL (NOT sent in full to LLM).
    pub variables: HashMap<String, ContextVariable>,
    /// Total size of all externalized context.
    pub total_size_bytes: usize,
    /// Any warnings about context size.
    pub warnings: Vec<String>,
}

impl ExternalizedContext {
    /// Create externalized context from a session context.
    pub fn from_session(ctx: &SessionContext, query: impl Into<String>) -> Self {
        Self::from_session_with_config(ctx, query, &ExternalizationConfig::default())
    }

    /// Create externalized context with custom configuration.
    pub fn from_session_with_config(
        ctx: &SessionContext,
        query: impl Into<String>,
        config: &ExternalizationConfig,
    ) -> Self {
        let mut variables = HashMap::new();
        let size_config = SizeConfig::default();
        let mut total_size = 0usize;

        // Externalize conversation
        if !ctx.messages.is_empty() && config.externalize_conversation {
            let size = ctx
                .messages
                .iter()
                .map(|m| m.content.len() + 50) // +50 for role, metadata overhead
                .sum();
            let var = ContextVariable::new_with_config(
                "conversation",
                ContextVarType::Conversation,
                size,
                ctx.messages.len(),
                &size_config,
            );
            total_size += size;
            variables.insert("conversation".to_string(), var);
        }

        // Externalize files
        if !ctx.files.is_empty() && config.externalize_files {
            let size: usize = ctx.files.values().map(|c| c.len()).sum();
            let var = ContextVariable::new_with_config(
                "files",
                ContextVarType::Files,
                size,
                ctx.files.len(),
                &size_config,
            );
            total_size += size;
            variables.insert("files".to_string(), var);
        }

        // Externalize tool outputs
        if !ctx.tool_outputs.is_empty() && config.externalize_tool_outputs {
            let size: usize = ctx
                .tool_outputs
                .iter()
                .map(|o| o.content.len() + o.tool_name.len() + 50)
                .sum();
            let var = ContextVariable::new_with_config(
                "tool_outputs",
                ContextVarType::ToolOutputs,
                size,
                ctx.tool_outputs.len(),
                &size_config,
            );
            total_size += size;
            variables.insert("tool_outputs".to_string(), var);
        }

        // Externalize working memory
        if !ctx.working_memory.is_empty() && config.externalize_working_memory {
            let size: usize = ctx
                .working_memory
                .iter()
                .map(|(k, v)| k.len() + v.to_string().len())
                .sum();
            let var = ContextVariable::new_with_config(
                "working_memory",
                ContextVarType::WorkingMemory,
                size,
                ctx.working_memory.len(),
                &size_config,
            );
            total_size += size;
            variables.insert("working_memory".to_string(), var);
        }

        let mut externalized = Self {
            query: query.into(),
            variables,
            total_size_bytes: total_size,
            warnings: Vec::new(),
        };
        externalized.warnings = externalized
            .check_size_limits(&size_config)
            .into_iter()
            .map(|warning| warning.message())
            .collect();
        externalized
    }

    /// Generate the root prompt for the LLM (SPEC-25.02).
    ///
    /// The prompt includes:
    /// - The user's query
    /// - Variable summaries (not full content)
    /// - Instructions for using REPL helpers
    pub fn root_prompt(&self) -> String {
        self.root_prompt_with_config(&RootPromptConfig::default())
    }

    /// Generate root prompt with custom configuration.
    pub fn root_prompt_with_config(&self, config: &RootPromptConfig) -> String {
        let mut prompt = String::new();

        // Query section
        prompt.push_str(&format!("## Query\n\n{}\n\n", self.query));

        // Context variables section
        if !self.variables.is_empty() {
            prompt.push_str("## Available Context Variables\n\n");
            prompt.push_str(
                "The following context is available as Python variables in the REPL.\n",
            );
            prompt.push_str("Use the helper functions to access them efficiently.\n\n");

            for (name, var) in &self.variables {
                prompt.push_str(&format!("- **{}**: {}\n", name, var.summary));
            }
            prompt.push('\n');
        }

        // Helper functions documentation
        if config.include_helper_docs && !self.variables.is_empty() {
            prompt.push_str("## Context Access Helpers\n\n");
            prompt.push_str("```python\n");
            prompt.push_str("# Slice messages (start/end are indices)\n");
            prompt.push_str("peek(conversation, start=0, end=10)\n\n");
            prompt.push_str("# Literal search in files\n");
            prompt.push_str("search(files, pattern=\"auth\")\n\n");
            prompt.push_str("# Regex search in files (set regex=True)\n");
            prompt.push_str("search(files, pattern=r\"def\\s+auth\", regex=True)\n\n");
            prompt.push_str("# Find semantically relevant chunks\n");
            prompt.push_str("find_relevant(files, query=\"authentication flow\", top_k=5)\n\n");
            prompt.push_str("# Summarize a tool output\n");
            prompt.push_str("summarize(tool_outputs[-1])\n\n");
            prompt.push_str("# Get length of any context variable\n");
            prompt.push_str("len(conversation)\n");
            prompt.push_str("```\n\n");
        }

        // Warnings
        if config.include_warnings && !self.warnings.is_empty() {
            prompt.push_str("## Warnings\n\n");
            for warning in &self.warnings {
                prompt.push_str(&format!("- ⚠️ {}\n", warning));
            }
            prompt.push('\n');
        }

        // Instructions
        if config.include_instructions {
            prompt.push_str("## Instructions\n\n");
            prompt.push_str(
                "DO NOT ask me to paste the full context. Instead, use the REPL helpers above ",
            );
            prompt.push_str(
                "to access exactly what you need. This keeps the conversation efficient.\n",
            );
            prompt.push_str("When you have the final structured result, call SUBMIT({...}) exactly once.\n");
            prompt.push_str(
                "Do not stop at print/debug output; SUBMIT is required to complete the task.\n",
            );
        }

        prompt
    }

    /// Get REPL setup code to initialize context variables.
    ///
    /// This code should be executed in the REPL before the main task.
    pub fn repl_setup_code(&self, ctx: &SessionContext) -> String {
        let mut code = String::new();
        code.push_str("# Context variable setup\n");
        code.push_str(
            "# Helpers are preloaded in the sandbox: peek, search, summarize, find_relevant\n\n",
        );

        // Set up conversation
        if self.variables.contains_key("conversation") {
            code.push_str("conversation = [\n");
            for msg in &ctx.messages {
                let role = format!("{}", msg.role);
                let content = msg.content.replace('\\', "\\\\").replace('"', "\\\"");
                // Truncate very long messages in setup
                let content = if content.len() > 1000 {
                    format!("{}...[truncated]", &content[..1000])
                } else {
                    content
                };
                code.push_str(&format!(
                    "    {{\"role\": \"{}\", \"content\": \"{}\"}},\n",
                    role, content
                ));
            }
            code.push_str("]\n\n");
        }

        // Set up files
        if self.variables.contains_key("files") {
            code.push_str("files = {\n");
            for (path, content) in &ctx.files {
                let content = content.replace('\\', "\\\\").replace('"', "\\\"");
                // Truncate very long files in setup
                let content = if content.len() > 5000 {
                    format!("{}...[truncated, use search() for full access]", &content[..5000])
                } else {
                    content
                };
                code.push_str(&format!("    \"{}\": \"\"\"{}\"\"\",\n", path, content));
            }
            code.push_str("}\n\n");
        }

        // Set up tool outputs
        if self.variables.contains_key("tool_outputs") {
            code.push_str("tool_outputs = [\n");
            for output in &ctx.tool_outputs {
                let content = output.content.replace('\\', "\\\\").replace('"', "\\\"");
                let content = if content.len() > 2000 {
                    format!("{}...[truncated]", &content[..2000])
                } else {
                    content
                };
                code.push_str(&format!(
                    "    {{\"tool\": \"{}\", \"content\": \"{}\", \"exit_code\": {}}},\n",
                    output.tool_name,
                    content,
                    output.exit_code.unwrap_or(0)
                ));
            }
            code.push_str("]\n\n");
        }

        // Set up working memory
        if self.variables.contains_key("working_memory") {
            code.push_str("working_memory = ");
            code.push_str(&serde_json::to_string_pretty(&ctx.working_memory).unwrap_or_else(|_| "{}".to_string()));
            code.push_str("\n\n");
        }

        code
    }

    /// Check size limits and return typed warnings.
    pub fn check_size_limits(&self, config: &SizeConfig) -> Vec<SizeWarning> {
        let mut warnings = Vec::new();

        for (name, var) in &self.variables {
            if var.size_bytes > config.chunk_threshold {
                if var.chunk_count.is_none() {
                    warnings.push(SizeWarning::RequiresChunking {
                        name: name.clone(),
                        size: var.size_bytes,
                        suggested_chunks: suggested_chunk_count(
                            var.size_bytes,
                            config.warn_threshold,
                        ),
                    });
                }
            } else if var.size_bytes > config.warn_threshold {
                warnings.push(SizeWarning::LargeVariable {
                    name: name.clone(),
                    size: var.size_bytes,
                    threshold: config.warn_threshold,
                });
            }
        }

        if self.total_size_bytes > config.max_total_size {
            warnings.push(SizeWarning::TotalSizeExceeded {
                total: self.total_size_bytes,
                max: config.max_total_size,
            });
        }

        warnings
    }

    /// Auto-chunk large variables based on configured thresholds.
    pub fn auto_chunk(&mut self, config: &SizeConfig) {
        for var in self.variables.values_mut() {
            if var.size_bytes > config.chunk_threshold {
                let chunks = suggested_chunk_count(var.size_bytes, config.warn_threshold);
                var.mark_chunked(chunks);
            } else {
                var.size_warning = var.size_bytes > config.warn_threshold;
                var.requires_chunking = false;
                var.chunk_count = None;
            }
        }

        self.warnings = self
            .check_size_limits(config)
            .into_iter()
            .map(|warning| warning.message())
            .collect();
    }

    /// Check if total context size is within default limits.
    pub fn is_within_limits(&self) -> bool {
        self.total_size_bytes <= SizeConfig::default().max_total_size
    }

    /// Get variables that require chunking.
    pub fn variables_requiring_chunking(&self) -> Vec<&ContextVariable> {
        self.variables
            .values()
            .filter(|v| v.requires_chunking)
            .collect()
    }
}

fn suggested_chunk_count(size_bytes: usize, chunk_size: usize) -> usize {
    let chunk_size = chunk_size.max(1);
    size_bytes.div_ceil(chunk_size)
}

/// Configuration for context externalization.
#[derive(Debug, Clone)]
pub struct ExternalizationConfig {
    /// Whether to externalize conversation history.
    pub externalize_conversation: bool,
    /// Whether to externalize cached files.
    pub externalize_files: bool,
    /// Whether to externalize tool outputs.
    pub externalize_tool_outputs: bool,
    /// Whether to externalize working memory.
    pub externalize_working_memory: bool,
}

impl Default for ExternalizationConfig {
    fn default() -> Self {
        Self {
            externalize_conversation: true,
            externalize_files: true,
            externalize_tool_outputs: true,
            externalize_working_memory: true,
        }
    }
}

/// Configuration for root prompt generation.
#[derive(Debug, Clone)]
pub struct RootPromptConfig {
    /// Include documentation for helper functions.
    pub include_helper_docs: bool,
    /// Include warnings about large context.
    pub include_warnings: bool,
    /// Include instructions about not pasting full context.
    pub include_instructions: bool,
}

impl Default for RootPromptConfig {
    fn default() -> Self {
        Self {
            include_helper_docs: true,
            include_warnings: true,
            include_instructions: true,
        }
    }
}

/// Variable access helper definitions for REPL (SPEC-25.03).
///
/// These are Python functions that should be available in the REPL.
#[derive(Debug, Clone)]
pub struct VariableAccessHelper {
    /// Function name.
    pub name: &'static str,
    /// Function signature.
    pub signature: &'static str,
    /// Brief description.
    pub description: &'static str,
    /// Python implementation.
    pub implementation: &'static str,
}

impl VariableAccessHelper {
    /// Get all standard helpers.
    pub fn standard_helpers() -> Vec<Self> {
        vec![
            Self {
                name: "peek",
                signature: "peek(data, start=0, end=None)",
                description: "Slice string/sequence data for inspection",
                implementation: r#"
def peek(data, start=0, end=None):
    """Peek at a slice of data.

    Args:
        data: Data to inspect
        start: Start index
        end: End index (default: None = to end)

    Returns:
        String preview of the selected content
    """
    if isinstance(data, str):
        lines = data.splitlines()
        return '\n'.join(lines[start:end])
    if isinstance(data, (list, tuple)):
        sliced = data[start:end]
        if all(isinstance(item, str) for item in sliced):
            return '\n'.join(sliced)
        return repr(sliced)
    if hasattr(data, '__getitem__'):
        return repr(data[start:end])
    return repr(data)
"#,
            },
            Self {
                name: "search",
                signature: "search(data, pattern, regex=False, case_sensitive=True, context_lines=0)",
                description: "Search strings/lists/dicts with literal or regex pattern",
                implementation: r#"
def search(data, pattern, regex=False, case_sensitive=True, context_lines=0):
    """Search for pattern in data.

    Args:
        data: Data to search
        pattern: Pattern to search for
        regex: Interpret pattern as regex when True
        case_sensitive: Match case-sensitive when True
        context_lines: Include surrounding lines for string matches

    Returns:
        List of match dictionaries with location metadata
    """
    import re
    flags = 0 if case_sensitive else re.IGNORECASE
    compiled = re.compile(pattern if regex else re.escape(pattern), flags)
    matches = []
    if isinstance(data, str):
        lines = data.splitlines()
        for i, line in enumerate(lines):
            if compiled.search(line):
                result = {'index': i, 'content': line}
                if context_lines > 0:
                    start = max(0, i - context_lines)
                    end = min(len(lines), i + context_lines + 1)
                    result['context'] = '\n'.join(lines[start:end])
                matches.append(result)
    elif isinstance(data, (list, tuple)):
        for i, item in enumerate(data):
            item_str = item if isinstance(item, str) else str(item)
            if compiled.search(item_str):
                matches.append({'index': i, 'content': item})
    elif isinstance(data, dict):
        for key, value in data.items():
            if compiled.search(str(key)) or compiled.search(str(value)):
                matches.append({'key': key, 'content': value})
    return matches
"#,
            },
            Self {
                name: "summarize",
                signature: "summarize(data, max_tokens=500, focus=None)",
                description: "Create a deferred LLM summary operation",
                implementation: r#"
def summarize(data, max_tokens=500, focus=None):
    """Summarize data using an LLM (deferred).

    Args:
        data: Data to summarize
        max_tokens: Maximum summary tokens
        focus: Optional focus direction

    Returns:
        Deferred summarize operation
    """
    content = data if isinstance(data, str) else str(data)
    prompt = f"Summarize the following in at most {max_tokens} tokens"
    if focus:
        prompt += f", focusing on {focus}"
    prompt += f":\n\n{content}"
    return get_registry().create(
        OperationType.SUMMARIZE,
        params={
            'content': content,
            'max_tokens': max_tokens,
            'focus': focus,
            'prompt': prompt,
        },
    )
"#,
            },
            Self {
                name: "find_relevant",
                signature: "find_relevant(data, query, top_k=5)",
                description: "Create a deferred embedding-relevance search operation",
                implementation: r#"
def find_relevant(data, query, top_k=5):
    """Find relevant chunks for a query (deferred embedding search).

    Args:
        data: Data to search
        query: Query string
        top_k: Number of relevant chunks to return

    Returns:
        Deferred embedding search operation
    """
    if isinstance(data, str):
        chunks = [data]
    elif isinstance(data, list):
        chunks = [str(item) for item in data]
    else:
        chunks = [str(data)]
    return get_registry().create(
        OperationType.EMBED,
        params={
            'query': query,
            'chunks': chunks,
            'top_k': top_k,
        },
    )
"#,
            },
        ]
    }

    /// Generate Python module code for all helpers.
    pub fn generate_module() -> String {
        let mut code = String::new();
        code.push_str("\"\"\"RLM context access helpers.\n\n");
        code.push_str("These functions mirror the active helpers in rlm_repl.helpers.\n");
        code.push_str("\"\"\"\n\n");
        code.push_str("from rlm_repl.deferred import OperationType, get_registry\n\n");

        for helper in Self::standard_helpers() {
            code.push_str(helper.implementation);
            code.push('\n');
        }

        code.push_str("\n__all__ = ['peek', 'search', 'summarize', 'find_relevant']\n");
        code
    }
}

/// Context size tracker for monitoring and limits (SPEC-25.04).
#[derive(Debug, Clone, Default)]
pub struct ContextSizeTracker {
    /// Size history by variable name.
    pub history: HashMap<String, Vec<usize>>,
    /// Current sizes.
    pub current: HashMap<String, usize>,
    /// Total bytes tracked.
    pub total_bytes: usize,
}

impl ContextSizeTracker {
    /// Create a new tracker.
    pub fn new() -> Self {
        Self::default()
    }

    /// Update size for a variable.
    pub fn update(&mut self, name: &str, size: usize) {
        // Update history
        self.history
            .entry(name.to_string())
            .or_default()
            .push(size);

        // Update current
        if let Some(old_size) = self.current.insert(name.to_string(), size) {
            self.total_bytes = self.total_bytes.saturating_sub(old_size);
        }
        self.total_bytes += size;
    }

    /// Check if a variable exceeds the warning threshold.
    pub fn exceeds_warning(&self, name: &str) -> bool {
        self.current.get(name).copied().unwrap_or(0) > WARN_SIZE_BYTES
    }

    /// Check if a variable requires chunking.
    pub fn requires_chunking(&self, name: &str) -> bool {
        self.current.get(name).copied().unwrap_or(0) > REQUIRE_CHUNKING_BYTES
    }

    /// Get growth rate for a variable (bytes per update).
    pub fn growth_rate(&self, name: &str) -> Option<f64> {
        let history = self.history.get(name)?;
        if history.len() < 2 {
            return None;
        }
        let growth: f64 = history
            .windows(2)
            .map(|w| w[1] as f64 - w[0] as f64)
            .sum();
        Some(growth / (history.len() - 1) as f64)
    }

    /// Generate warnings for all variables.
    pub fn warnings(&self) -> Vec<String> {
        let mut warnings = Vec::new();

        for (name, &size) in &self.current {
            if size > REQUIRE_CHUNKING_BYTES {
                warnings.push(format!(
                    "{} exceeds {}MB ({:.1}MB) - chunking required",
                    name,
                    REQUIRE_CHUNKING_BYTES / (1024 * 1024),
                    size as f64 / (1024.0 * 1024.0)
                ));
            } else if size > WARN_SIZE_BYTES {
                warnings.push(format!(
                    "{} exceeds {}KB ({:.1}KB)",
                    name,
                    WARN_SIZE_BYTES / 1024,
                    size as f64 / 1024.0
                ));
            }
        }

        warnings
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;

    #[test]
    fn test_context_variable_creation() {
        let var = ContextVariable::new("conversation", ContextVarType::Conversation, 50000, 100);
        assert_eq!(var.name, "conversation");
        assert!(!var.size_warning); // 50KB < 100KB
        assert!(!var.requires_chunking);
        assert!(var.summary.contains("100 messages"));
    }

    #[test]
    fn test_context_variable_size_warning() {
        let var = ContextVariable::new("files", ContextVarType::Files, 150 * 1024, 10);
        assert!(var.size_warning); // 150KB > 100KB
        assert!(!var.requires_chunking); // 150KB < 1MB
    }

    #[test]
    fn test_context_variable_requires_chunking() {
        let var = ContextVariable::new("files", ContextVarType::Files, 2 * 1024 * 1024, 50);
        assert!(var.size_warning);
        assert!(var.requires_chunking); // 2MB > 1MB
    }

    #[test]
    fn test_check_size_limits_with_explicit_config() {
        let mut variables = HashMap::new();
        variables.insert(
            "files".to_string(),
            ContextVariable::new_with_config(
                "files",
                ContextVarType::Files,
                250_000,
                5,
                &SizeConfig {
                    warn_threshold: 80_000,
                    chunk_threshold: 200_000,
                    max_total_size: 400_000,
                },
            ),
        );
        variables.insert(
            "conversation".to_string(),
            ContextVariable::new_with_config(
                "conversation",
                ContextVarType::Conversation,
                120_000,
                30,
                &SizeConfig {
                    warn_threshold: 80_000,
                    chunk_threshold: 200_000,
                    max_total_size: 400_000,
                },
            ),
        );

        let externalized = ExternalizedContext {
            query: "Q".to_string(),
            variables,
            total_size_bytes: 420_000,
            warnings: Vec::new(),
        };
        let config = SizeConfig {
            warn_threshold: 80_000,
            chunk_threshold: 200_000,
            max_total_size: 400_000,
        };
        let warnings = externalized.check_size_limits(&config);

        assert!(warnings.iter().any(|warning| matches!(
            warning,
            SizeWarning::RequiresChunking { name, .. } if name == "files"
        )));
        assert!(warnings.iter().any(|warning| matches!(
            warning,
            SizeWarning::LargeVariable { name, .. } if name == "conversation"
        )));
        assert!(warnings.iter().any(|warning| matches!(
            warning,
            SizeWarning::TotalSizeExceeded { .. }
        )));
    }

    #[test]
    fn test_auto_chunk_marks_variable_and_clears_chunking_requirement() {
        let mut ctx = SessionContext::new();
        ctx.cache_file("/large.txt", &"x".repeat(250_000));
        let mut externalized = ExternalizedContext::from_session(&ctx, "chunk me");
        let config = SizeConfig {
            warn_threshold: 64_000,
            chunk_threshold: 128_000,
            max_total_size: 600_000,
        };

        externalized.auto_chunk(&config);

        let files = externalized
            .variables
            .get("files")
            .expect("files variable should exist");
        assert_eq!(files.chunk_count, Some(4));
        assert!(!files.requires_chunking);
        assert!(files.summary.contains("auto_chunked into 4 chunks"));
        assert!(!externalized.warnings.iter().any(|warning| {
            warning.contains("requires chunking")
        }));
    }

    #[test]
    fn test_externalized_context_from_session() {
        let mut ctx = SessionContext::new();
        ctx.add_user_message("Hello");
        ctx.add_assistant_message("Hi there!");
        ctx.cache_file("/src/main.rs", "fn main() {}");

        let externalized = ExternalizedContext::from_session(&ctx, "Test query");

        assert_eq!(externalized.query, "Test query");
        assert!(externalized.variables.contains_key("conversation"));
        assert!(externalized.variables.contains_key("files"));
        assert_eq!(externalized.variables["conversation"].item_count, 2);
        assert_eq!(externalized.variables["files"].item_count, 1);
    }

    #[test]
    fn test_root_prompt_generation() {
        let mut ctx = SessionContext::new();
        ctx.add_user_message("Analyze auth");
        ctx.cache_file("/src/auth.rs", "fn auth() {}");

        let externalized = ExternalizedContext::from_session(&ctx, "Analyze the auth system");
        let prompt = externalized.root_prompt();

        assert!(prompt.contains("## Query"));
        assert!(prompt.contains("Analyze the auth system"));
        assert!(prompt.contains("## Available Context Variables"));
        assert!(prompt.contains("conversation"));
        assert!(prompt.contains("files"));
        assert!(prompt.contains("peek("));
        assert!(prompt.contains("search("));
        assert!(prompt.contains("find_relevant("));
        assert!(prompt.contains("SUBMIT({...})"));
    }

    #[test]
    fn test_root_prompt_omits_full_context_content() {
        let mut ctx = SessionContext::new();
        ctx.add_user_message("Analyze auth");
        ctx.cache_file(
            "/src/auth.rs",
            "fn auth_secret() { panic!(\"do-not-include-in-root-prompt\"); }",
        );

        let externalized = ExternalizedContext::from_session(&ctx, "Analyze the auth system");
        let prompt = externalized.root_prompt();
        assert!(!prompt.contains("do-not-include-in-root-prompt"));
    }

    #[test]
    fn test_externalization_config() {
        let mut ctx = SessionContext::new();
        ctx.add_user_message("Test");
        ctx.cache_file("/test.rs", "test");

        let config = ExternalizationConfig {
            externalize_conversation: false,
            externalize_files: true,
            externalize_tool_outputs: true,
            externalize_working_memory: true,
        };

        let externalized =
            ExternalizedContext::from_session_with_config(&ctx, "Query", &config);

        assert!(!externalized.variables.contains_key("conversation"));
        assert!(externalized.variables.contains_key("files"));
    }

    #[test]
    fn test_size_tracker() {
        let mut tracker = ContextSizeTracker::new();

        tracker.update("conversation", 50_000);
        assert!(!tracker.exceeds_warning("conversation"));

        tracker.update("conversation", 150_000);
        assert!(tracker.exceeds_warning("conversation"));
        assert!(!tracker.requires_chunking("conversation"));

        tracker.update("files", 2_000_000);
        assert!(tracker.requires_chunking("files"));

        let warnings = tracker.warnings();
        assert!(warnings.iter().any(|w| w.contains("conversation")));
        assert!(warnings.iter().any(|w| w.contains("files")));
    }

    #[test]
    fn test_growth_rate() {
        let mut tracker = ContextSizeTracker::new();

        tracker.update("conversation", 1000);
        assert!(tracker.growth_rate("conversation").is_none()); // Need 2+ points

        tracker.update("conversation", 2000);
        tracker.update("conversation", 3000);
        tracker.update("conversation", 4000);

        let rate = tracker.growth_rate("conversation").unwrap();
        assert!((rate - 1000.0).abs() < 0.01); // 1000 bytes per update
    }

    #[test]
    fn test_helper_module_generation() {
        let module = VariableAccessHelper::generate_module();

        assert!(module.contains("def peek("));
        assert!(module.contains("def search("));
        assert!(module.contains("def summarize("));
        assert!(module.contains("def find_relevant("));
        assert!(module.contains("OperationType"));
        assert!(module.contains("__all__ = ['peek', 'search', 'summarize', 'find_relevant']"));
        assert!(module.contains("__all__"));
    }

    #[test]
    fn test_standard_helper_signatures_match_runtime_surface() {
        let helpers = VariableAccessHelper::standard_helpers();

        assert_eq!(helpers.len(), 4);
        assert!(
            helpers
                .iter()
                .any(|helper| helper.signature == "peek(data, start=0, end=None)")
        );
        assert!(helpers.iter().any(|helper| {
            helper.signature
                == "search(data, pattern, regex=False, case_sensitive=True, context_lines=0)"
        }));
        assert!(
            helpers
                .iter()
                .any(|helper| helper.signature == "summarize(data, max_tokens=500, focus=None)")
        );
        assert!(
            helpers
                .iter()
                .any(|helper| helper.signature == "find_relevant(data, query, top_k=5)")
        );
    }

    #[test]
    fn test_repl_setup_code() {
        let mut ctx = SessionContext::new();
        ctx.add_user_message("Test message");
        ctx.cache_file("/src/test.rs", "fn test() {}");

        let externalized = ExternalizedContext::from_session(&ctx, "Query");
        let setup = externalized.repl_setup_code(&ctx);

        assert!(setup.contains("conversation = ["));
        assert!(setup.contains("files = {"));
        assert!(setup.contains("Helpers are preloaded in the sandbox"));
    }
}
