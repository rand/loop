"""Type stubs for rlm_core Python bindings."""

from __future__ import annotations
from typing import Optional, Dict, List, Any
from enum import IntEnum

__version__: str

# Compatibility helpers
def version() -> str: ...
def version_tuple() -> tuple[int, int, int]: ...
def has_feature(feature_name: str) -> bool: ...
def available_features() -> list[str]: ...

# Optional adversarial compatibility types
class IssueSeverity(IntEnum):
    Critical = 0
    High = 1
    Medium = 2
    Low = 3
    Info = 4

class ValidationContext: ...
class ValidationResult: ...
class AdversarialConfig: ...

# Context types

class Role(IntEnum):
    User = 0
    Assistant = 1
    System = 2
    Tool = 3

class Message:
    def __init__(
        self, role: Role, content: str, timestamp: Optional[str] = None
    ) -> None: ...
    @staticmethod
    def user(content: str) -> Message: ...
    @staticmethod
    def assistant(content: str) -> Message: ...
    @staticmethod
    def system(content: str) -> Message: ...
    @staticmethod
    def tool(content: str) -> Message: ...
    @property
    def role(self) -> Role: ...
    @property
    def content(self) -> str: ...
    @property
    def timestamp(self) -> Optional[str]: ...

class ToolOutput:
    def __init__(
        self, tool_name: str, content: str, exit_code: Optional[int] = None
    ) -> None: ...
    @property
    def tool_name(self) -> str: ...
    @property
    def content(self) -> str: ...
    @property
    def exit_code(self) -> Optional[int]: ...
    @property
    def timestamp(self) -> Optional[str]: ...
    def is_success(self) -> bool: ...

class SessionContext:
    def __init__(self) -> None: ...
    def add_message(self, message: Message) -> None: ...
    def add_user_message(self, content: str) -> None: ...
    def add_assistant_message(self, content: str) -> None: ...
    def cache_file(self, path: str, content: str) -> None: ...
    def add_tool_output(self, output: ToolOutput) -> None: ...
    def set_memory(self, key: str, value: Any) -> None: ...
    def get_memory(self, key: str) -> Any: ...
    def messages(self) -> List[Message]: ...
    def last_messages(self, n: int) -> List[Message]: ...
    def files(self) -> Dict[str, str]: ...
    def get_file(self, path: str) -> Optional[str]: ...
    def tool_outputs(self) -> List[ToolOutput]: ...
    def message_count(self) -> int: ...
    def file_count(self) -> int: ...
    def spans_multiple_directories(self) -> bool: ...
    def total_message_tokens(self) -> int: ...

# Memory types

class NodeType(IntEnum):
    Entity = 0
    Fact = 1
    Experience = 2
    Decision = 3
    Snippet = 4

class Tier(IntEnum):
    Task = 0
    Session = 1
    LongTerm = 2
    Archive = 3
    def next(self) -> Optional[Tier]: ...
    def previous(self) -> Optional[Tier]: ...

class Node:
    def __init__(
        self,
        node_type: NodeType,
        content: str,
        subtype: Optional[str] = None,
        tier: Optional[Tier] = None,
        confidence: Optional[float] = None,
    ) -> None: ...
    @property
    def id(self) -> str: ...
    @property
    def node_type(self) -> NodeType: ...
    @property
    def subtype(self) -> Optional[str]: ...
    @property
    def content(self) -> str: ...
    @property
    def tier(self) -> Tier: ...
    @property
    def confidence(self) -> float: ...
    @property
    def created_at(self) -> str: ...
    @property
    def updated_at(self) -> str: ...
    @property
    def last_accessed(self) -> str: ...
    @property
    def access_count(self) -> int: ...
    def record_access(self) -> None: ...
    def is_decayed(self, min_confidence: float) -> bool: ...
    def age_hours(self) -> int: ...

class HyperEdge:
    def __init__(
        self,
        edge_type: str,
        label: Optional[str] = None,
        weight: Optional[float] = None,
    ) -> None: ...
    @property
    def id(self) -> str: ...
    @property
    def edge_type(self) -> str: ...
    @property
    def label(self) -> Optional[str]: ...
    @property
    def weight(self) -> float: ...
    @property
    def created_at(self) -> str: ...
    def node_ids(self) -> List[str]: ...
    def contains(self, node_id: str) -> bool: ...

class MemoryStats:
    @property
    def total_nodes(self) -> int: ...
    @property
    def total_edges(self) -> int: ...
    @property
    def nodes_by_tier(self) -> Dict[str, int]: ...
    @property
    def nodes_by_type(self) -> Dict[str, int]: ...

class MemoryStore:
    @staticmethod
    def in_memory() -> MemoryStore: ...
    @staticmethod
    def open(path: str) -> MemoryStore: ...
    def add_node(self, node: Node) -> str: ...
    def get_node(self, node_id: str) -> Optional[Node]: ...
    def query_by_type(self, node_type: NodeType, limit: int) -> List[Node]: ...
    def query_by_tier(self, tier: Tier, limit: int) -> List[Node]: ...
    def search_content(self, query: str, limit: int) -> List[Node]: ...
    def update_node(self, node: Node) -> None: ...
    def delete_node(self, node_id: str) -> bool: ...
    def promote(self, node_ids: List[str], reason: str) -> List[str]: ...
    def decay(self, factor: float, min_confidence: float) -> List[str]: ...
    def stats(self) -> MemoryStats: ...

# LLM types

class Provider(IntEnum):
    Anthropic = 0
    OpenAI = 1
    OpenRouter = 2

class ModelTier(IntEnum):
    Flagship = 0
    Balanced = 1
    Fast = 2

class QueryType(IntEnum):
    Architecture = 0
    MultiFile = 1
    Debugging = 2
    Extraction = 3
    Simple = 4
    @staticmethod
    def classify(query: str) -> QueryType: ...
    def base_tier(self) -> ModelTier: ...

class ModelSpec:
    def __init__(
        self,
        id: str,
        name: str,
        provider: Provider,
        tier: ModelTier,
        context_window: int,
        max_output: int,
        input_cost: float,
        output_cost: float,
    ) -> None: ...
    @staticmethod
    def claude_opus() -> ModelSpec: ...
    @staticmethod
    def claude_sonnet() -> ModelSpec: ...
    @staticmethod
    def claude_haiku() -> ModelSpec: ...
    @staticmethod
    def gpt4o() -> ModelSpec: ...
    @staticmethod
    def gpt4o_mini() -> ModelSpec: ...
    @property
    def id(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def provider(self) -> Provider: ...
    @property
    def tier(self) -> ModelTier: ...
    @property
    def context_window(self) -> int: ...
    @property
    def max_output(self) -> int: ...
    @property
    def input_cost_per_m(self) -> float: ...
    @property
    def output_cost_per_m(self) -> float: ...
    @property
    def supports_caching(self) -> bool: ...
    @property
    def supports_vision(self) -> bool: ...
    @property
    def supports_tools(self) -> bool: ...
    def calculate_cost(self, input_tokens: int, output_tokens: int) -> float: ...

class ChatMessage:
    @staticmethod
    def system(content: str) -> ChatMessage: ...
    @staticmethod
    def user(content: str) -> ChatMessage: ...
    @staticmethod
    def assistant(content: str) -> ChatMessage: ...
    @property
    def role(self) -> str: ...
    @property
    def content(self) -> str: ...

class TokenUsage:
    def __init__(
        self,
        input_tokens: int,
        output_tokens: int,
        cache_read: Optional[int] = None,
        cache_creation: Optional[int] = None,
    ) -> None: ...
    @property
    def input_tokens(self) -> int: ...
    @property
    def output_tokens(self) -> int: ...
    @property
    def cache_read_tokens(self) -> Optional[int]: ...
    @property
    def cache_creation_tokens(self) -> Optional[int]: ...
    def total(self) -> int: ...
    def effective_input_tokens(self) -> int: ...

class CompletionRequest:
    def __init__(self) -> None: ...
    def with_model(self, model: str) -> CompletionRequest: ...
    def with_system(self, system: str) -> CompletionRequest: ...
    def with_message(self, message: ChatMessage) -> CompletionRequest: ...
    def with_max_tokens(self, max_tokens: int) -> CompletionRequest: ...
    def with_temperature(self, temperature: float) -> CompletionRequest: ...
    def with_caching(self, enable: bool) -> CompletionRequest: ...
    @property
    def model(self) -> Optional[str]: ...
    @property
    def system(self) -> Optional[str]: ...
    @property
    def max_tokens(self) -> Optional[int]: ...
    @property
    def temperature(self) -> Optional[float]: ...

class CompletionResponse:
    @property
    def id(self) -> str: ...
    @property
    def model(self) -> str: ...
    @property
    def content(self) -> str: ...
    @property
    def stop_reason(self) -> Optional[str]: ...
    @property
    def usage(self) -> TokenUsage: ...
    @property
    def timestamp(self) -> str: ...
    @property
    def cost(self) -> Optional[float]: ...

class RoutingContext:
    def __init__(self) -> None: ...
    def with_depth(self, depth: int) -> RoutingContext: ...
    def with_max_depth(self, max_depth: int) -> RoutingContext: ...
    def with_budget(self, budget: float) -> RoutingContext: ...
    def with_provider(self, provider: Provider) -> RoutingContext: ...
    def requiring_caching(self) -> RoutingContext: ...
    def requiring_vision(self) -> RoutingContext: ...
    def requiring_tools(self) -> RoutingContext: ...
    @property
    def depth(self) -> int: ...
    @property
    def max_depth(self) -> int: ...
    @property
    def remaining_budget(self) -> Optional[float]: ...

class RoutingDecision:
    @property
    def model(self) -> ModelSpec: ...
    @property
    def query_type(self) -> QueryType: ...
    @property
    def tier(self) -> ModelTier: ...
    @property
    def reason(self) -> str: ...
    @property
    def estimated_cost(self) -> Optional[float]: ...

class SmartRouter:
    def __init__(self) -> None: ...
    def route(self, query: str, context: RoutingContext) -> RoutingDecision: ...
    def models(self) -> List[ModelSpec]: ...

class CostTracker:
    def __init__(self) -> None: ...
    def record(self, model: str, usage: TokenUsage, cost: Optional[float] = None) -> None: ...
    def merge(self, other: CostTracker) -> None: ...
    @property
    def total_input_tokens(self) -> int: ...
    @property
    def total_output_tokens(self) -> int: ...
    @property
    def total_cache_read_tokens(self) -> int: ...
    @property
    def total_cost(self) -> float: ...
    @property
    def request_count(self) -> int: ...
    @property
    def by_model(self) -> Dict[str, Dict[str, float]]: ...

# Trajectory types

class TrajectoryEventType(IntEnum):
    RlmStart = 0
    Analyze = 1
    ReplExec = 2
    ReplResult = 3
    Reason = 4
    RecurseStart = 5
    RecurseEnd = 6
    Final = 7
    Error = 8
    ToolUse = 9
    CostReport = 10
    VerifyStart = 11
    ClaimExtracted = 12
    EvidenceChecked = 13
    BudgetComputed = 14
    HallucinationFlag = 15
    VerifyComplete = 16
    Memory = 17
    Externalize = 18
    Decompose = 19
    Synthesize = 20

class TrajectoryEvent:
    def __init__(
        self, event_type: TrajectoryEventType, content: str, depth: int = 0
    ) -> None: ...
    @staticmethod
    def rlm_start(query: str) -> TrajectoryEvent: ...
    @staticmethod
    def analyze(analysis: str, depth: int = 0) -> TrajectoryEvent: ...
    @staticmethod
    def repl_exec(depth: int, code: str) -> TrajectoryEvent: ...
    @staticmethod
    def repl_result(depth: int, result: str, success: bool = True) -> TrajectoryEvent: ...
    @staticmethod
    def reason(depth: int, reasoning: str) -> TrajectoryEvent: ...
    @staticmethod
    def recurse_start(depth: int, query: str) -> TrajectoryEvent: ...
    @staticmethod
    def recurse_end(depth: int, result: str) -> TrajectoryEvent: ...
    @staticmethod
    def final_answer(answer: str, depth: int = 0) -> TrajectoryEvent: ...
    @staticmethod
    def error(depth: int, error: str) -> TrajectoryEvent: ...
    @property
    def event_type(self) -> TrajectoryEventType: ...
    @property
    def depth(self) -> int: ...
    @property
    def content(self) -> str: ...
    @property
    def timestamp(self) -> str: ...
    def with_metadata(self, key: str, value: Any) -> TrajectoryEvent: ...
    def get_metadata(self, key: str) -> Any: ...
    def log_line(self) -> str: ...
    def to_json(self) -> str: ...
    @staticmethod
    def from_json(json: str) -> TrajectoryEvent: ...

# Complexity types

class ActivationDecision:
    @property
    def should_activate(self) -> bool: ...
    @property
    def reason(self) -> str: ...
    @property
    def score(self) -> int: ...

class PatternClassifier:
    def __init__(self) -> None: ...
    def should_activate(
        self, query: str, context: SessionContext
    ) -> ActivationDecision: ...
